/*
 * Token expansion system - Header
 *
 * Provides stack-based ANSI escape code generation from markup tokens.
 * Generated by Ragel from tokens.rl
 *
 * Token Types:
 *
 * SEMANTIC TOKENS (composite styles, configurable via globals):
 *   {b}         - Bold only (same as {strong})
 *   {highlight} - Bold + yellow (for highlighting, e.g., fuzzy matches)
 *   {h1}-{h6}   - Heading styles (default: h1=orange, h2=blue, h3-h6=white)
 *   {strong}    - Strong/bold text
 *   {dim}       - Gray foreground (bright black)
 *   {section}   - Bold + dark gray background, for selection highlighting
 *   {danger}    - Dark red background (for warnings/deletions)
 *   {strike}    - Strikethrough text (alias for {strikethrough})
 *   {text}      - Full reset (alias for {reset})
 *
 * ATTRIBUTE TOKENS:
 *   {bold}, {B}         - Bold text
 *   {italic}, {I}, {i}  - Italic text
 *   {underline}, {U}, {u} - Underlined text
 *   {reverse}           - Reverse/inverse video
 *   {strikethrough}     - Strikethrough text
 *   {bright}            - Brighten current foreground color
 *
 * FOREGROUND COLORS:
 *   {black}, {red}, {green}, {yellow}, {blue}, {magenta}, {cyan}, {white}
 *   {gray}, {grey}      - Gray (bright black)
 *   {bright:COLOR}      - Bright variant (e.g., {bright:red})
 *   {fg:N}              - 256-color foreground (N = 0-255)
 *
 * BACKGROUND COLORS:
 *   {bg:COLOR}          - Background color (e.g., {bg:red})
 *   {bg:N}              - 256-color background (N = 0-255)
 *
 * RESET/POP TOKENS:
 *   {/}                 - Pop one level, restore previous style
 *   {reset}             - Full reset, clear stack
 *   {/fg}               - Reset foreground color only
 *   {/bg}               - Reset background color only
 *   {/b}                - Legacy: same as {/}
 *   {/section}          - Legacy: same as {/}
 *   {/strike}           - Legacy: same as {/}
 *
 * CONTROL TOKENS (terminal control sequences):
 *   {clr}               - Clear to end of line (ESC[K)
 *   {cls}               - Clear to end of screen (ESC[J)
 *   {home}              - Move cursor to home position (ESC[H)
 *   {hide}              - Hide cursor (ESC[?25l)
 *   {show}              - Show cursor (ESC[?25h)
 *   {goto:row,col}      - Move cursor to position (ESC[row;colH)
 *   {goto_cursor}       - Move cursor to {cursor} marker position
 *
 * SPECIAL:
 *   {cursor}            - Mark cursor position (for cursor tracking)
 *
 * Stack Semantics:
 *   Each style-setting token pushes its previous state onto a stack.
 *   {/} pops one level, restoring the previous state.
 *   Composite tokens (like {highlight}) push multiple attrs and a composite marker,
 *   so a single {/} restores all of them at once.
 *
 * Auto-reset:
 *   All styles are automatically reset at the end of each line (before newline).
 *   This ensures clean line boundaries without trailing ANSI codes.
 *
 * Redundancy avoidance:
 *   Repeated identical styles don't emit redundant codes.
 *   e.g., "{dim}{dim}{dim}x" outputs same as "{dim}x"
 *
 * Example:
 *   "Normal {highlight}bold yellow {red}now red{/} back to yellow{/} normal"
 *   "Nested: {bold}{italic}bold+italic{/}just bold{/}normal"
 */

#ifndef TOKENS_H
#define TOKENS_H

#include "zstr.h"
#include <stdbool.h>

/*
 * Global style configuration for semantic tokens.
 * These can be modified at runtime to customize appearance.
 * Format: ANSI SGR parameter string (without leading \033[ or trailing m)
 */
extern const char *token_style_h1;      /* Default: "1m\033[38;5;214" (bold+orange) */
extern const char *token_style_h2;      /* Default: "1;34" (bold+blue) */
extern const char *token_style_h3;      /* Default: "1;37" (bold+white) */
extern const char *token_style_h4;      /* Default: "1;37" (bold+white) */
extern const char *token_style_h5;      /* Default: "1;37" (bold+white) */
extern const char *token_style_h6;        /* Default: "1;37" (bold+white) */
extern const char *token_style_b;         /* Default: "1" (bold) */
extern const char *token_style_strong;    /* Default: "1" (bold) */
extern const char *token_style_highlight; /* Default: "1;33" (bold+yellow) */
extern const char *token_style_dim;       /* Default: "90" (gray) */
extern const char *token_style_danger;    /* Default: "48;5;52" (dark red bg) */

/* Global flags for controlling token expansion */
extern bool zstr_disable_token_expansion;  /* If true, pass through unchanged */
extern bool zstr_no_colors;                /* If true, tokens expand to empty strings */

/* Result of token expansion with state tracking */
typedef struct {
    zstr expanded;    /* The expanded string with ANSI codes */
    int cursor_col;   /* Visual column of {cursor} marker (1-indexed), or -1 if not found */
    int cursor_row;   /* Visual row of {cursor} marker (1-indexed), or -1 if not found */
    bool has_cursor;  /* True if {cursor} was found in the input */
    int final_col;    /* Final visual column after expansion */
    int final_row;    /* Final visual row after expansion */
} TokenExpansion;

/*
 * Core expansion functions (operate on C strings)
 */

/* Expand tokens, returning expanded string and state */
TokenExpansion expand_tokens_with_cursor(const char *text);

/* Expand tokens, returning just the expanded string */
zstr expand_tokens(const char *text);

/* Free a TokenExpansion (just frees the expanded zstr) */
static inline void token_expansion_free(TokenExpansion *te) {
    zstr_free(&te->expanded);
}

/*
 * zstr wrapper functions (for convenience when working with zstr)
 */

/* Expand tokens from C string, returning expanded string and state */
static inline TokenExpansion zstr_expand_tokens_with_cursor(const char *text) {
    return expand_tokens_with_cursor(text);
}

/* Expand tokens from C string, returning just the expanded string */
static inline zstr zstr_expand_tokens(const char *text) {
    return expand_tokens(text);
}

/*
 * Direct output functions - expand tokens and write directly to stream
 */

#include <stdio.h>

/* Expand tokens and write to FILE* stream (e.g., stdout, stderr) */
void zstr_expand_to(FILE *stream, const char *text);

/*
 * Render a TokenExpansion to a stream.
 * If has_cursor is true, appends {goto_cursor}{show} and clears to end of line.
 * This provides a complete render with proper cursor positioning.
 */
void token_expansion_render(FILE *stream, TokenExpansion *te);

#endif /* TOKENS_H */
